package ranking

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"math"
	"math/rand"
	"net/http"
	"os"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/bwmarrin/discordgo"
	"github.com/go-redis/redis/v8"
	"github.com/joho/godotenv"
)

// CaseBank –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä—É –±–∞–Ω–∫–∞ –∫–µ–π—Å–æ–≤
type CaseBank struct {
	Cases       map[string]int `json:"cases"`
	LastUpdated time.Time      `json:"last_updated"`
}

var RarityEmojis = map[string]string{
	"Common":     "üü¶",
	"Rare":       "üü™",
	"Super-rare": "üüß",
	"Epic":       "üü®",
	"Nephrite":   "üü•",
	"Exotic":     "üü©",
	"Legendary":  "‚≠ê",
}

// BitcoinTracker –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç –∫—É—Ä—Å –∏ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å BTC
type BitcoinTracker struct {
	CurrentPrice  float64
	PreviousPrice float64
	LastUpdate    time.Time
	PriceHistory  []float64
	mu            sync.Mutex
}

// RarityVolatility –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å —Ü–µ–Ω—ã –¥–ª—è –∫–∞–∂–¥–æ–π —Ä–µ–¥–∫–æ—Å—Ç–∏
var RarityVolatility = map[string]float64{
	"Common":     10.0,   // ¬±50% - –±—ã–ª–æ 0.1 (10%)
	"Rare":       100.0,  // ¬±100% - –±—ã–ª–æ 0.3 (30%)
	"Super-rare": 200.0,  // ¬±200% - –±—ã–ª–æ 0.6 (60%)
	"Epic":       400.0,  // ¬±400% - –±—ã–ª–æ 1.0 (100%)
	"Nephrite":   600.0,  // ¬±600% - –±—ã–ª–æ 1.5 (150%)
	"Exotic":     800.0,  // ¬±800% - –±—ã–ª–æ 2.0 (200%)
	"Legendary":  1000.0, // ¬±1000% - –±—ã–ª–æ 3.0 (300%)
}

// BaseRarityPrices –±–∞–∑–æ–≤—ã–µ —Ü–µ–Ω—ã –≤ USD –¥–ª—è –∫–∞–∂–¥–æ–π —Ä–µ–¥–∫–æ—Å—Ç–∏
var BaseRarityPrices = map[string]float64{
	"Common":     10,
	"Rare":       50,
	"Super-rare": 200,
	"Epic":       1000,
	"Nephrite":   5000,
	"Exotic":     5000,
	"Legendary":  10000,
}

// Ranking —É–ø—Ä–∞–≤–ª—è–µ—Ç —Ä–µ–π—Ç–∏–Ω–≥–∞–º–∏, –æ–ø—Ä–æ—Å–∞–º–∏, –∏–≥—Ä–∞–º–∏ –∏ –≥–æ–ª–æ—Å–æ–≤–æ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å—é.
type Ranking struct {
	mu                sync.Mutex
	admins            map[string]bool
	polls             map[string]*Poll
	duels             map[string]*Duel
	redis             *redis.Client
	ctx               context.Context
	voiceAct          map[string]int
	redBlackGames     map[string]*RedBlackGame
	blackjackGames    map[string]*BlackjackGame
	floodChannelID    string
	logChannelID      string
	cinemaOptions     []CinemaOption
	pendingCinemaBids map[string]PendingCinemaBid
	cinemaChannelID   string
	Kki               *KKI
	sellMessageIDs    map[string]string // userID -> messageID
	caseBank          *CaseBank
	stopResetChan     chan struct{}
	BitcoinTracker    *BitcoinTracker // –ù–û–í–û–ï –ü–û–õ–ï
}

// NewRanking –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä—É Ranking.
func NewRanking(adminFilePath, redisAddr, floodChannelID, cinemaChannelID string) (*Ranking, error) {
	err := godotenv.Load()
	if err != nil {
		log.Fatal("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ .env —Ñ–∞–π–ª–∞")
	}

	r := &Ranking{
		admins:            make(map[string]bool),
		polls:             make(map[string]*Poll),
		duels:             make(map[string]*Duel),
		voiceAct:          map[string]int{},
		redBlackGames:     make(map[string]*RedBlackGame),
		blackjackGames:    make(map[string]*BlackjackGame),
		ctx:               context.Background(),
		floodChannelID:    floodChannelID,
		logChannelID:      os.Getenv("LOG_CHANNEL_ID"),
		cinemaOptions:     []CinemaOption{},
		pendingCinemaBids: make(map[string]PendingCinemaBid),
		cinemaChannelID:   cinemaChannelID,
		sellMessageIDs:    make(map[string]string),
		caseBank: &CaseBank{
			Cases:       make(map[string]int),
			LastUpdated: time.Now(),
		},
		BitcoinTracker: &BitcoinTracker{
			PriceHistory: make([]float64, 0),
		},
	}

	// –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Redis —Å –ø–æ–≤—Ç–æ—Ä–Ω—ã–º–∏ –ø–æ–ø—ã—Ç–∫–∞–º–∏
	var redisErr error
	for i := 0; i < 5; i++ {
		r.redis = redis.NewClient(&redis.Options{
			Addr:     redisAddr,
			Password: os.Getenv("REDIS_PASSWORD"),
		})
		_, redisErr = r.redis.Ping(r.ctx).Result()
		if redisErr == nil {
			break
		}
		log.Printf("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ Redis (–ø–æ–ø—ã—Ç–∫–∞ %d/5): %v", i+1, redisErr)
		time.Sleep(5 * time.Second)
	}
	if redisErr != nil {
		return nil, fmt.Errorf("–Ω–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ Redis –ø–æ—Å–ª–µ 5 –ø–æ–ø—ã—Ç–æ–∫: %v", redisErr)
	}

	// –ó–∞–≥—Ä—É–∑–∫–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤ –∏–∑ —Ñ–∞–π–ª–∞
	file, err := os.Open(adminFilePath)
	if err != nil {
		return nil, fmt.Errorf("–Ω–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤: %v", err)
	}
	defer file.Close()

	var admins struct {
		IDs []string `json:"admin_ids"`
	}
	if err := json.NewDecoder(file).Decode(&admins); err != nil {
		return nil, fmt.Errorf("–Ω–µ —É–¥–∞–ª–æ—Å—å —Ä–∞–∑–æ–±—Ä–∞—Ç—å —Ñ–∞–π–ª –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤: %v", err)
	}
	for _, id := range admins.IDs {
		r.admins[id] = true
	}

	// –ü–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ –∫—É—Ä—Å–∞ BTC
	if _, err := r.GetBitcoinPrice(); err != nil {
		log.Printf("–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ: –Ω–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∫—É—Ä—Å BTC: %v", err)
	}

	// –ó–∞–ø—É—Å–∫–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ü–µ–Ω
	go r.StartPriceUpdater()

	r.stopResetChan = make(chan struct{})
	go r.startDailyReset()
	// –ó–∞–≥—Ä—É–∑–∫–∞ cinema options
	r.LoadCinemaOptions()

	// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è KKI
	r.Kki, err = NewKKI(r.ctx)
	if err != nil {
		log.Fatalf("Failed to init KKI: %v", err)
	}
	if err := r.Kki.SyncFromSheets(r); err != nil {
		log.Printf("Failed initial sync: %v", err)
	}

	log.Printf("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω —Ä–µ–π—Ç–∏–Ω–≥ —Å %d –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º–∏", len(r.admins))

	// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–Ω–∫–∞ –∫–µ–π—Å–æ–≤
	r.initializeCaseBank()
	// –ó–∞–ø—É—Å–∫ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –±–∞–Ω–∫–∞ –∫–µ–π—Å–æ–≤ –∫–∞–∂–¥—ã–µ 10 –º–∏–Ω—É—Ç
	go r.StartBitcoinUpdater() // <- –î–û–ë–ê–í–¨–¢–ï –≠–¢–£ –°–¢–†–û–ö–£

	return r, nil
}

// IsAdmin –ø—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.
func (r *Ranking) IsAdmin(userID string) bool {
	r.mu.Lock()
	defer r.mu.Unlock()
	isAdmin := r.admins[userID]
	log.Printf("–ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ %s: %v", userID, isAdmin)
	return isAdmin
}

// generateGameID —Å–æ–∑–¥–∞—ë—Ç —É–Ω–∏–∫–∞–ª—å–Ω—ã–π ID –¥–ª—è –∏–≥—Ä—ã.
func generateGameID(playerID string) string {
	rand.Seed(time.Now().UnixNano())
	// –ó–∞–º–µ–Ω—è–µ–º _ –Ω–∞ - –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –ø—Ä–æ–±–ª–µ–º —Å –ø–∞—Ä—Å–∏–Ω–≥–æ–º
	safePlayerID := strings.ReplaceAll(playerID, "_", "-")
	return fmt.Sprintf("%s-%d-%d", safePlayerID, time.Now().UnixNano(), rand.Intn(10000))
}

// generatePollID —Å–æ–∑–¥–∞—ë—Ç —É–Ω–∏–∫–∞–ª—å–Ω—ã–π 5-—Å–∏–º–≤–æ–ª—å–Ω—ã–π ID –¥–ª—è –æ–ø—Ä–æ—Å–∞.
func generatePollID() string {
	const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	rand.Seed(time.Now().UnixNano())
	id := make([]byte, 5)
	for i := range id {
		id[i] = letters[rand.Intn(len(letters))]
	}
	return string(id)
}

// LogCreditOperation –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –ª–æ–≥ –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å –∫—Ä–µ–¥–∏—Ç–∞–º–∏ –≤ –∫–∞–Ω–∞–ª –ª–æ–≥–æ–≤.
func (r *Ranking) LogCreditOperation(s *discordgo.Session, message string) {
	if r.logChannelID != "" {
		_, err := s.ChannelMessageSend(r.logChannelID, message)
		if err != nil {
			log.Printf("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –ª–æ–≥ –≤ –∫–∞–Ω–∞–ª %s: %v", r.logChannelID, err)
		}
	}
}

// GetUserInventory –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å NFT –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
func (r *Ranking) GetUserInventory(userID string) UserInventory {
	jsonData, err := r.redis.Get(r.ctx, "inventory:"+userID).Bytes()
	if err == redis.Nil {
		return make(UserInventory)
	}
	var inv UserInventory
	if err := json.Unmarshal(jsonData, &inv); err != nil {
		return make(UserInventory)
	}
	return inv
}

// SaveUserInventory —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å NFT –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
func (r *Ranking) SaveUserInventory(userID string, inv UserInventory) {
	jsonData, _ := json.Marshal(inv)
	r.redis.Set(r.ctx, "inventory:"+userID, jsonData, 0)
}

// HandleInventoryCommand –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
func (r *Ranking) HandleInventoryCommand(s *discordgo.Session, m *discordgo.MessageCreate) {
	inv := r.GetUserInventory(m.Author.ID)
	if len(inv) == 0 {
		s.ChannelMessageSend(m.ChannelID, "üéí **–í–∞—à –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å –ø—É—Å—Ç** ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n–ù–∏—á–µ–≥–æ –Ω–µ—Ç, –ò–º–ø–µ—Ä–∞—Ç–æ—Ä –∂–¥—ë—Ç –¥–æ–±—ã—á–∏! üò¢")
		return
	}

	var lines []string
	for nftID, count := range inv {
		nft, ok := r.Kki.nfts[nftID]
		if !ok {
			continue
		}
		rarityEmoji := RarityEmojis[nft.Rarity]
		lines = append(lines, fmt.Sprintf("%s **%s** (x%d)\nüìå ID –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –∏ –ø—Ä–æ–¥–∞–∂–∏: %s\nüí∞ –¶–µ–Ω–∞: %d | %s", rarityEmoji, nft.Name, count, nftID, nft.Price, nft.Rarity))
	}
	sort.Strings(lines)
	embed := &discordgo.MessageEmbed{
		Title:       "üéí **–ò–Ω–≤–µ–Ω—Ç–∞—Ä—å** ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê",
		Description: strings.Join(lines, "\n\n"),
		Color:       0x00FF00,
		Footer:      &discordgo.MessageEmbedFooter{Text: fmt.Sprintf("–í–ª–∞–¥–µ–ª–µ—Ü: %s | –°–ª–∞–≤—å –ò–º–ø–µ—Ä–∞—Ç–æ—Ä–∞! üëë", m.Author.Username)},
	}
	s.ChannelMessageSendEmbed(m.ChannelID, embed)
}

// HandleSellCommand !sell <nftID> <count>
func (r *Ranking) HandleSellCommand(s *discordgo.Session, m *discordgo.MessageCreate, command string) {
	parts := strings.Fields(command)
	if len(parts) != 3 {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ**: !sell <nftID> <count>")
		return
	}
	nftID, countStr := parts[1], parts[2]
	count, err := strconv.Atoi(countStr)
	if err != nil || count <= 0 {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ**")
		return
	}

	// –ü—Ä–æ–≤–µ—Ä–∫–∞ NFT
	nft, ok := r.Kki.nfts[nftID]
	if !ok {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **NFT –Ω–µ –Ω–∞–π–¥–µ–Ω–æ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ ID.**")
		return
	}

	// –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è
	inv := r.GetUserInventory(m.Author.ID)
	if inv[nftID] < count {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ NFT –¥–ª—è –ø—Ä–æ–¥–∞–∂–∏.**")
		return
	}

	// –†–∞—Å—á—ë—Ç —Å—É–º–º—ã - –¢–ï–ü–ï–†–¨ –ü–û–õ–ù–ê–Ø –¶–ï–ù–ê –≤–º–µ—Å—Ç–æ /2
	sellPrice := nft.Price * count // –£–±—Ä–∞–ª–∏ –¥–µ–ª–µ–Ω–∏–µ –Ω–∞ 2

	// –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è —Å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ–º
	customID := fmt.Sprintf("sell_confirm_%s_%s_%d_%d", m.Author.ID, nftID, count, sellPrice)
	cancelID := fmt.Sprintf("sell_cancel_%s", m.Author.ID)
	embed := &discordgo.MessageEmbed{
		Title:       "üÉè **–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –ø—Ä–æ–¥–∞–∂–∏** ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê",
		Description: fmt.Sprintf("–í—ã —Ö–æ—Ç–∏—Ç–µ –ø—Ä–æ–¥–∞—Ç—å %d x %s **%s** (ID –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –∏ –ø—Ä–æ–¥–∞–∂–∏: %s) –∑–∞ üí∞ %d –∫—Ä–µ–¥–∏—Ç–æ–≤?", count, RarityEmojis[nft.Rarity], nft.Name, nftID, sellPrice),
		Color:       RarityColors[nft.Rarity],
		Footer:      &discordgo.MessageEmbedFooter{Text: fmt.Sprintf("–í–ª–∞–¥–µ–ª–µ—Ü: %s | –°–ª–∞–≤—å –ò–º–ø–µ—Ä–∞—Ç–æ—Ä–∞! üëë", m.Author.Username)},
	}
	components := []discordgo.MessageComponent{
		discordgo.ActionsRow{
			Components: []discordgo.MessageComponent{
				discordgo.Button{
					Label:    "‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å",
					Style:    discordgo.SuccessButton,
					CustomID: customID,
				},
				discordgo.Button{
					Label:    "‚ùå –û—Ç–º–µ–Ω–∏—Ç—å",
					Style:    discordgo.DangerButton,
					CustomID: cancelID,
				},
			},
		},
	}
	msg, err := s.ChannelMessageSendComplex(m.ChannelID, &discordgo.MessageSend{
		Embed:      embed,
		Components: components,
	})
	if err != nil {
		log.Printf("Failed to send sell confirmation: %v", err)
		return
	}
	r.mu.Lock()
	r.sellMessageIDs[m.Author.ID] = msg.ID
	r.mu.Unlock()
}

// HandleSellConfirm –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –ø—Ä–æ–¥–∞–∂–∏
func (r *Ranking) HandleSellConfirm(s *discordgo.Session, i *discordgo.InteractionCreate) {
	parts := strings.Split(i.MessageComponentData().CustomID, "_")
	if len(parts) != 6 {
		s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
			Type: discordgo.InteractionResponseChannelMessageWithSource,
			Data: &discordgo.InteractionResponseData{Content: "‚ùå **–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø—Ä–æ–¥–∞–∂–∏.**"},
		})
		return
	}
	userID, nftID, countStr, sellPriceStr := parts[2], parts[3], parts[4], parts[5]
	if userID != i.Member.User.ID {
		s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
			Type: discordgo.InteractionResponseChannelMessageWithSource,
			Data: &discordgo.InteractionResponseData{Content: "‚ùå **–ö–Ω–æ–ø–∫–∞ –Ω–µ –¥–ª—è –≤–∞—Å! –ò–º–ø–µ—Ä–∞—Ç–æ—Ä –≥–Ω–µ–≤–µ–Ω! üëë**"},
		})
		return
	}
	count, err := strconv.Atoi(countStr)
	if err != nil {
		s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
			Type: discordgo.InteractionResponseChannelMessageWithSource,
			Data: &discordgo.InteractionResponseData{Content: "‚ùå **–û—à–∏–±–∫–∞: –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ.**"},
		})
		return
	}
	sellPrice, err := strconv.Atoi(sellPriceStr)
	if err != nil {
		s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
			Type: discordgo.InteractionResponseChannelMessageWithSource,
			Data: &discordgo.InteractionResponseData{Content: "‚ùå **–û—à–∏–±–∫–∞: –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Å—É–º–º–∞.**"},
		})
		return
	}

	inv := r.GetUserInventory(userID)
	if inv[nftID] < count {
		s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
			Type: discordgo.InteractionResponseChannelMessageWithSource,
			Data: &discordgo.InteractionResponseData{Content: "‚ùå **–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ NFT.**"},
		})
		return
	}

	// –£–º–µ–Ω—å—à–µ–Ω–∏–µ NFT
	inv[nftID] -= count
	if inv[nftID] == 0 {
		delete(inv, nftID)
	}
	r.SaveUserInventory(userID, inv)

	// –ù–∞—á–∏—Å–ª–µ–Ω–∏–µ –∫—Ä–µ–¥–∏—Ç–æ–≤
	r.UpdateRating(userID, sellPrice)

	// –û—Ç–ø—Ä–∞–≤–∫–∞ –ª–æ–≥–∞
	nft := r.Kki.nfts[nftID]
	r.LogCreditOperation(s, fmt.Sprintf("üÉè **%s** –ø—Ä–æ–¥–∞–ª %d x %s **%s** (ID: %s) –∑–∞ üí∞ %d –∫—Ä–µ–¥–∏—Ç–æ–≤.", i.Member.User.Username, count, RarityEmojis[nft.Rarity], nft.Name, nftID, sellPrice))

	// –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –∫–Ω–æ–ø–æ–∫
	// –í HandleSellConfirm —Ç–æ–∂–µ –æ–±–Ω–æ–≤–ª—è–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ
	embed := &discordgo.MessageEmbed{
    Title:       "üÉè **–ü—Ä–æ–¥–∞–∂–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞** ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê",
    Description: fmt.Sprintf("‚úÖ **–ü—Ä–æ–¥–∞–Ω–æ** %d x %s **%s** (ID: %s) –∑–∞ üí∞ %d –∫—Ä–µ–¥–∏—Ç–æ–≤!", count, RarityEmojis[nft.Rarity], nft.Name, nftID, sellPrice),
    Color:       RarityColors[nft.Rarity],
    Footer:      &discordgo.MessageEmbedFooter{Text: fmt.Sprintf("–í–ª–∞–¥–µ–ª–µ—Ü: %s | –°–ª–∞–≤—å –ò–º–ø–µ—Ä–∞—Ç–æ—Ä–∞! üëë", i.Member.User.Username)},
}
	emptyComponents := []discordgo.MessageComponent{}
	_, err = s.ChannelMessageEditComplex(&discordgo.MessageEdit{
		Channel:    i.ChannelID,
		ID:         i.Message.ID,
		Embed:      embed,
		Components: &emptyComponents,
	})
	if err != nil {
		log.Printf("Failed to update sell message: %v", err)
	}

	s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
		Type: discordgo.InteractionResponseChannelMessageWithSource,
		Data: &discordgo.InteractionResponseData{
			Content: fmt.Sprintf("‚úÖ **–ü—Ä–æ–¥–∞–Ω–æ** %d x %s **%s** (ID: %s) –∑–∞ üí∞ %d –∫—Ä–µ–¥–∏—Ç–æ–≤!", count, RarityEmojis[nft.Rarity], nft.Name, nftID, sellPrice),
		},
	})

	r.mu.Lock()
	delete(r.sellMessageIDs, userID)
	r.mu.Unlock()
}

// HandleSellCancel –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –æ—Ç–º–µ–Ω—É –ø—Ä–æ–¥–∞–∂–∏
func (r *Ranking) HandleSellCancel(s *discordgo.Session, i *discordgo.InteractionCreate) {
	if strings.Split(i.MessageComponentData().CustomID, "_")[2] != i.Member.User.ID {
		s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
			Type: discordgo.InteractionResponseChannelMessageWithSource,
			Data: &discordgo.InteractionResponseData{Content: "‚ùå **–ö–Ω–æ–ø–∫–∞ –Ω–µ –¥–ª—è –≤–∞—Å! –ò–º–ø–µ—Ä–∞—Ç–æ—Ä –≥–Ω–µ–≤–µ–Ω! üëë**"},
		})
		return
	}
	embed := &discordgo.MessageEmbed{
		Title:       "üÉè **–ü—Ä–æ–¥–∞–∂–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞** ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê",
		Description: "‚ùå –ü—Ä–æ–¥–∞–∂–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞. –ò–º–ø–µ—Ä–∞—Ç–æ—Ä —Ä–∞–∑–æ—á–∞—Ä–æ–≤–∞–Ω! üò¢",
		Color:       0xFF0000,
		Footer:      &discordgo.MessageEmbedFooter{Text: fmt.Sprintf("–í–ª–∞–¥–µ–ª–µ—Ü: %s | –°–ª–∞–≤—å –ò–º–ø–µ—Ä–∞—Ç–æ—Ä–∞! üëë", i.Member.User.Username)},
	}
	emptyComponents := []discordgo.MessageComponent{}
	_, err := s.ChannelMessageEditComplex(&discordgo.MessageEdit{
		Channel:    i.ChannelID,
		ID:         i.Message.ID,
		Embed:      embed,
		Components: &emptyComponents,
	})
	if err != nil {
		log.Printf("Failed to update sell cancel message: %v", err)
	}
	s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
		Type: discordgo.InteractionResponseChannelMessageWithSource,
		Data: &discordgo.InteractionResponseData{Content: "‚ùå **–ü—Ä–æ–¥–∞–∂–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞.**"},
	})
	r.mu.Lock()
	delete(r.sellMessageIDs, i.Member.User.ID)
	r.mu.Unlock()
}

// HandleTradeNFTCommand !trade_nft <@user> <nftID> <count>
func (r *Ranking) HandleTradeNFTCommand(s *discordgo.Session, m *discordgo.MessageCreate, command string) {
	if len(m.Mentions) != 1 {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–£–ø–æ–º—è–Ω–∏—Ç–µ –æ–¥–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è**: !trade_nft @user <nftID> <count>")
		return
	}
	targetID := m.Mentions[0].ID
	if targetID == m.Author.ID {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–ù–µ–ª—å–∑—è –ø–µ—Ä–µ–¥–∞—Ç—å NFT —Å–µ–±–µ.**")
		return
	}
	parts := strings.Fields(command)
	if len(parts) != 4 {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ**: !trade_nft @user <nftID> <count>")
		return
	}
	nftID, countStr := parts[2], parts[3]
	count, err := strconv.Atoi(countStr)
	if err != nil || count <= 0 {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ.**")
		return
	}

	// –ü—Ä–æ–≤–µ—Ä–∫–∞ NFT
	nft, ok := r.Kki.nfts[nftID]
	if !ok {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **NFT –Ω–µ –Ω–∞–π–¥–µ–Ω–æ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ ID.**")
		return
	}

	// –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è
	inv := r.GetUserInventory(m.Author.ID)
	if inv[nftID] < count {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ NFT –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏.**")
		return
	}

	// –ü–µ—Ä–µ–¥–∞—á–∞ NFT
	inv[nftID] -= count
	if inv[nftID] == 0 {
		delete(inv, nftID)
	}
	r.SaveUserInventory(m.Author.ID, inv)

	targetInv := r.GetUserInventory(targetID)
	targetInv[nftID] += count
	r.SaveUserInventory(targetID, targetInv)

	// –û—Ç–≤–µ—Ç
	s.ChannelMessageSend(m.ChannelID, fmt.Sprintf("‚úÖ **–ü–µ—Ä–µ–¥–∞–Ω–æ** %d x üÉè **%s** (ID –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –∏ –ø—Ä–æ–¥–∞–∂–∏: %s) –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é <@%s>.", count, nft.Name, nftID, targetID))
}

// HandleCaseTradeCommand !case_trade <@user> <caseID> <count>
func (r *Ranking) HandleCaseTradeCommand(s *discordgo.Session, m *discordgo.MessageCreate, command string) {
	if len(m.Mentions) != 1 {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–£–ø–æ–º—è–Ω–∏—Ç–µ –æ–¥–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è**: !case_trade @user <caseID> <count>")
		return
	}
	sellerID := m.Mentions[0].ID
	if sellerID == m.Author.ID {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–ù–µ–ª—å–∑—è –∫—É–ø–∏—Ç—å –∫–µ–π—Å —É —Å–µ–±—è.**")
		return
	}
	parts := strings.Fields(command)
	if len(parts) != 4 {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ**: !case_trade @user <caseID> <count>")
		return
	}
	caseID := parts[2]
	count, err := strconv.Atoi(parts[3])
	if err != nil || count <= 0 {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ.**")
		return
	}

	// –£–Ω–∏—Ñ–∏–∫–∞—Ü–∏—è daily_case
	if caseID == "daily" {
		caseID = "daily_case"
	}
	kase, ok := r.Kki.cases[caseID]
	if !ok {
		s.ChannelMessageSend(m.ChannelID, fmt.Sprintf("‚ùå **–ö–µ–π—Å —Å ID %s –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ ID.**", caseID))
		return
	}

	sellerInv := r.Kki.GetUserCaseInventory(r, sellerID)
	if sellerInv[caseID] < count {
		sellerInvStr := ""
		for id, c := range sellerInv {
			k, _ := r.Kki.cases[id]
			sellerInvStr += fmt.Sprintf("%s (ID: %s, x%d), ", k.Name, id, c)
		}
		if sellerInvStr == "" {
			sellerInvStr = "–ø—É—Å—Ç"
		}
		s.ChannelMessageSend(m.ChannelID, fmt.Sprintf("‚ùå **–£ –ø—Ä–æ–¥–∞–≤—Ü–∞ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫–µ–π—Å–æ–≤.** –ò–Ω–≤–µ–Ω—Ç–∞—Ä—å –ø—Ä–æ–¥–∞–≤—Ü–∞: %s", sellerInvStr))
		return
	}

	price := kase.Price * count
	buyerCoins := r.GetRating(m.Author.ID)
	if buyerCoins < price {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫—Ä–µ–¥–∏—Ç–æ–≤.**")
		return
	}

	// –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—Ä–µ–¥–∏—Ç–æ–≤
	r.UpdateRating(m.Author.ID, -price)
	r.UpdateRating(sellerID, price)

	// –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è
	buyerInv := r.Kki.GetUserCaseInventory(r, m.Author.ID)
	buyerInv[caseID] += count
	r.Kki.SaveUserCaseInventory(r, m.Author.ID, buyerInv)

	sellerInv[caseID] -= count
	if sellerInv[caseID] == 0 {
		delete(sellerInv, caseID)
	}
	r.Kki.SaveUserCaseInventory(r, sellerID, sellerInv)

	// –õ–æ–≥ –æ–ø–µ—Ä–∞—Ü–∏–∏
	r.LogCreditOperation(s, fmt.Sprintf("üõí **%s** –∫—É–ø–∏–ª %d x üì¶ **%s** (ID: %s) —É <@%s> –∑–∞ üí∞ %d –∫—Ä–µ–¥–∏—Ç–æ–≤.", m.Author.Username, count, kase.Name, caseID, sellerID, price))

	s.ChannelMessageSend(m.ChannelID, fmt.Sprintf("üõí **–ö—É–ø–ª–µ–Ω–æ** %d x üì¶ **%s** (ID –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è/–ø–µ—Ä–µ–¥–∞—á–∏: %s) —É <@%s> –∑–∞ üí∞ %d –∫—Ä–µ–¥–∏—Ç–æ–≤.", count, kase.Name, caseID, sellerID, price))
}

// HandleOpenCaseCommand !open_case <caseID>
func (r *Ranking) HandleOpenCaseCommand(s *discordgo.Session, m *discordgo.MessageCreate, command string) {
	parts := strings.Split(command, " ")
	if len(parts) < 2 {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ**: !open_case <caseID>")
		return
	}
	caseID := parts[1]
	if caseID == "daily" {
		caseID = "daily_case"
	}
	kase, ok := r.Kki.cases[caseID]
	if !ok {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∫–µ–π—Å. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ ID.**")
		return
	}

	// –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è –∫–µ–π—Å–æ–≤
	userCaseInv := r.Kki.GetUserCaseInventory(r, m.Author.ID)
	if userCaseInv[caseID] < 1 {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–£ –≤–∞—Å –Ω–µ—Ç —ç—Ç–æ–≥–æ –∫–µ–π—Å–∞.**")
		return
	}
	userCaseInv[caseID]--
	if userCaseInv[caseID] == 0 {
		delete(userCaseInv, caseID)
	}
	r.Kki.SaveUserCaseInventory(r, m.Author.ID, userCaseInv)

	// –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–Ω–µ–≤–Ω–æ–≥–æ –ª–∏–º–∏—Ç–∞
	key := fmt.Sprintf("case_limit:%s:%s", m.Author.ID, time.Now().Format("2006-01-02"))
	opened, _ := r.redis.Get(r.ctx, key).Int()
	if opened >= 5 {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–î–æ—Å—Ç–∏–≥–Ω—É—Ç –¥–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç (5 –∫–µ–π—Å–æ–≤ –≤ –¥–µ–Ω—å).**")
		return
	}
	r.redis.Incr(r.ctx, key)
	r.redis.Expire(r.ctx, key, 24*time.Hour)

	// –ù–∞—á–∞–ª–æ –∞–Ω–∏–º–∞—Ü–∏–∏
	animMsg, _ := s.ChannelMessageSend(m.ChannelID, "üé∞ **–û—Ç–∫—Ä—ã–≤–∞–µ–º –∫–µ–π—Å...**")
	collections := strings.Split(kase.ContainedCollections, ",")
	var possibleNFTs []NFT
	for _, nft := range r.Kki.nfts {
		for _, col := range collections {
			if nft.Collection == col && (caseID != "daily_case" || nft.Collection != "holiday") {
				possibleNFTs = append(possibleNFTs, nft)
				break
			}
		}
	}
	if len(possibleNFTs) == 0 {
		s.ChannelMessageEdit(m.ChannelID, animMsg.ID, "‚ùå **–í –∫–µ–π—Å–µ –Ω–µ—Ç NFT.**")
		return
	}

	// –û—Ç–∫—Ä—ã—Ç–∏–µ 5 NFT
	var dropped []NFT
	for i := 0; i < 5; i++ {
		dropped = append(dropped, r.rollNFT(possibleNFTs))
	}

	// –ê–Ω–∏–º–∞—Ü–∏—è –≤ –≥–æ—Ä—É—Ç–∏–Ω–µ
	go func() {
		rarities := []string{"Common", "Rare", "Super-rare", "Epic", "Nephrite", "Exotic", "Legendary"}
		for i := 0; i < 10; i++ {
			randRarity := rarities[rand.Intn(len(rarities))]
			embed := &discordgo.MessageEmbed{
				Description: fmt.Sprintf("üé∞ **–ö—Ä—É—Ç–∏–º...** %s", randRarity),
				Color:       RarityColors[randRarity],
			}
			s.ChannelMessageEditEmbed(m.ChannelID, animMsg.ID, embed)
			time.Sleep(300 * time.Millisecond)
		}

		// –ü–æ–∫–∞–∑ –≤—ã–ø–∞–≤—à–∏—Ö NFT
		var lines []string
		inv := r.GetUserInventory(m.Author.ID)
		for _, nft := range dropped {
			wasEmpty := inv[nft.ID] == 0
			inv[nft.ID]++
			newTag := ""
			if wasEmpty {
				newTag = "\n**–ù–æ–≤–∞—è –≤ –∫–æ–ª–ª–µ–∫—Ü–∏–∏!** üéâ"
			}
			embed := &discordgo.MessageEmbed{
				Title:       fmt.Sprintf("üéâ **–í—ã–ø–∞–ª–æ**: %s **%s**", RarityEmojis[nft.Rarity], nft.Name),
				Description: fmt.Sprintf("**ID –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –∏ –ø—Ä–æ–¥–∞–∂–∏**: %s\n**–†–µ–¥–∫–æ—Å—Ç—å**: %s\n**–û–ø–∏—Å–∞–Ω–∏–µ**: %s\n**–î–∞—Ç–∞ –≤—ã–ø—É—Å–∫–∞**: %s\n**–¶–µ–Ω–∞**: üí∞ %d\n**–ö–æ–ª–ª–µ–∫—Ü–∏—è**: %s%s", nft.ID, nft.Rarity, nft.Description, nft.ReleaseDate, nft.Price, nft.Collection, newTag),
				Color:       RarityColors[nft.Rarity],
				Image:       &discordgo.MessageEmbedImage{URL: nft.ImageURL},
				Footer:      &discordgo.MessageEmbedFooter{Text: fmt.Sprintf("–í–ª–∞–¥–µ–ª–µ—Ü: %s | –°–ª–∞–≤—å –ò–º–ø–µ—Ä–∞—Ç–æ—Ä–∞! üëë", m.Author.Username)},
			}
			msg, err := s.ChannelMessageSendEmbed(m.ChannelID, embed)
			if err == nil {
				go func(msgID string) {
					time.Sleep(5 * time.Second)
					if err := s.ChannelMessageDelete(m.ChannelID, msgID); err != nil {
						log.Printf("Failed to delete message %s: %v", msgID, err)
					}
				}(msg.ID)
			} else {
				log.Printf("Failed to send embed for NFT %s: %v", nft.ID, err)
			}
			lines = append(lines, fmt.Sprintf("%s **%s** (ID: %s)", RarityEmojis[nft.Rarity], nft.Name, nft.ID))
			time.Sleep(1 * time.Second)
		}
		r.SaveUserInventory(m.Author.ID, inv)
		s.ChannelMessageSend(m.ChannelID, fmt.Sprintf("üéâ **–í—ã –ø–æ–ª—É—á–∏–ª–∏** ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n%s", strings.Join(lines, "\n")))
	}()
}

// rollNFT –≤—ã–±–∏—Ä–∞–µ—Ç —Å–ª—É—á–∞–π–Ω—ã–π NFT —Å —É—á—ë—Ç–æ–º —Ä–µ–¥–∫–æ—Å—Ç–∏
func (r *Ranking) rollNFT(possible []NFT) NFT {
	totalProb := 0.0
	for _, p := range RarityProbabilities {
		totalProb += p.Prob
	}
	roll := rand.Float64() * totalProb
	cum := 0.0
	var selectedRarity string
	for _, p := range RarityProbabilities {
		cum += p.Prob
		if roll <= cum {
			selectedRarity = p.Rarity
			break
		}
	}

	var candidates []NFT
	for _, nft := range possible {
		if nft.Rarity == selectedRarity {
			candidates = append(candidates, nft)
		}
	}
	if len(candidates) == 0 {
		return possible[rand.Intn(len(possible))]
	}
	return candidates[rand.Intn(len(candidates))]
}

// HandleDailyCaseCommand !daily_case
func (r *Ranking) HandleDailyCaseCommand(s *discordgo.Session, m *discordgo.MessageCreate) {
	key := fmt.Sprintf("daily_case:%s:%s", m.Author.ID, time.Now().Format("2006-01-02"))
	if r.redis.Exists(r.ctx, key).Val() > 0 {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–ï–∂–µ–¥–Ω–µ–≤–Ω—ã–π –∫–µ–π—Å —É–∂–µ –ø–æ–ª—É—á–µ–Ω —Å–µ–≥–æ–¥–Ω—è.**")
		return
	}

	// –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è daily_case
	if _, ok := r.Kki.cases["daily_case"]; !ok {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–ï–∂–µ–¥–Ω–µ–≤–Ω—ã–π –∫–µ–π—Å (ID: daily_case) –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –±–∞–∑–µ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ Google Sheets.**")
		log.Printf("daily_case not found in r.Kki.cases")
		return
	}

	userCaseInv := r.Kki.GetUserCaseInventory(r, m.Author.ID)
	userCaseInv["daily_case"]++ // –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ —Å "daily" –Ω–∞ "daily_case"
	err := r.Kki.SaveUserCaseInventory(r, m.Author.ID, userCaseInv)
	if err != nil {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∫–µ–π—Å–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.**")
		log.Printf("Failed to save daily_case for user %s: %v", m.Author.ID, err)
		return
	}

	r.redis.Set(r.ctx, key, "claimed", 24*time.Hour)
	s.ChannelMessageSend(m.ChannelID, "‚úÖ **–í—ã –ø–æ–ª—É—á–∏–ª–∏ –µ–∂–µ–¥–Ω–µ–≤–Ω—ã–π –∫–µ–π—Å!** –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ `!open_case daily_case` –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è.")
}

// HandleBuyCaseFromCommand !buy_case_from <@user> <caseID> <count>
func (r *Ranking) HandleBuyCaseFromCommand(s *discordgo.Session, m *discordgo.MessageCreate, command string) {
	parts := strings.Split(command, " ")
	if len(parts) < 4 {
		s.ChannelMessageSend(m.ChannelID, "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: !buy_case_from @user <caseID> <count>")
		return
	}
	sellerID := strings.Trim(parts[1], "<@!>")
	caseID := parts[2]
	count, _ := strconv.Atoi(parts[3])

	kase, ok := r.Kki.cases[caseID]
	if !ok {
		s.ChannelMessageSend(m.ChannelID, "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∫–µ–π—Å.")
		return
	}

	sellerInv := r.Kki.GetUserCaseInventory(r, sellerID)
	if sellerInv[caseID] < count {
		s.ChannelMessageSend(m.ChannelID, "–£ –ø—Ä–æ–¥–∞–≤—Ü–∞ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫–µ–π—Å–æ–≤.")
		return
	}

	price := kase.Price * count
	r.LogCreditOperation(s, fmt.Sprintf("%s –∫—É–ø–∏–ª %d x %s —É %s –∑–∞ %d –∫—Ä–µ–¥–∏—Ç–æ–≤", m.Author.Username, count, kase.Name, sellerID, price))

	buyerInv := r.Kki.GetUserCaseInventory(r, m.Author.ID)
	buyerInv[caseID] += count
	r.Kki.SaveUserCaseInventory(r, m.Author.ID, buyerInv)

	sellerInv[caseID] -= count
	if sellerInv[caseID] == 0 {
		delete(sellerInv, caseID)
	}
	r.Kki.SaveUserCaseInventory(r, sellerID, sellerInv)

	s.ChannelMessageSend(m.ChannelID, fmt.Sprintf("–ö—É–ø–ª–µ–Ω–æ %d x %s —É <@%s> –∑–∞ %d –∫—Ä–µ–¥–∏—Ç–æ–≤.", count, kase.Name, sellerID, price))
}

// HandleAdminGiveCase !admin_give_case <userID> <caseID>
func (r *Ranking) HandleAdminGiveCase(s *discordgo.Session, m *discordgo.MessageCreate, command string) {
	if len(m.Mentions) != 1 {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–£–ø–æ–º—è–Ω–∏—Ç–µ –æ–¥–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è**: !a_give_case @user <caseID>")
		return
	}
	userID := m.Mentions[0].ID
	parts := strings.Fields(command)
	if len(parts) != 3 {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ**: !a_give_case @user <caseID>")
		return
	}
	caseID := parts[2]
	kase, exists := r.Kki.cases[caseID]
	if !exists {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–ö–µ–π—Å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ ID.**")
		return
	}
	inv := r.Kki.GetUserCaseInventory(r, userID)
	inv[caseID]++
	r.Kki.SaveUserCaseInventory(r, userID, inv)
	s.ChannelMessageSend(m.ChannelID, fmt.Sprintf("‚úÖ **–í—ã–¥–∞–Ω** üì¶ **%s** (ID –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è/–ø–µ—Ä–µ–¥–∞—á–∏: %s) –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é <@%s>.", kase.Name, caseID, userID))
}

// HandleAdminGiveNFT !admin_give_nft <userID> <nftID> <count>
func (r *Ranking) HandleAdminGiveNFT(s *discordgo.Session, m *discordgo.MessageCreate, command string) {
	if len(m.Mentions) != 1 {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–£–ø–æ–º—è–Ω–∏—Ç–µ –æ–¥–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è**: !a_give_nft @user <nftID> <count>")
		return
	}
	userID := m.Mentions[0].ID
	parts := strings.Fields(command)
	if len(parts) != 4 {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ**: !a_give_nft @user <nftID> <count>")
		return
	}
	nftID, countStr := parts[2], parts[3]
	count, err := strconv.Atoi(countStr)
	if err != nil || count <= 0 {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ.**")
		return
	}

	// –ü—Ä–æ–≤–µ—Ä–∫–∞ NFT
	nft, ok := r.Kki.nfts[nftID]
	if !ok {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **NFT –Ω–µ –Ω–∞–π–¥–µ–Ω–æ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ ID.**")
		return
	}

	inv := r.GetUserInventory(userID)
	inv[nftID] += count
	r.SaveUserInventory(userID, inv)

	s.ChannelMessageSend(m.ChannelID, fmt.Sprintf("‚úÖ **–í—ã–¥–∞–Ω–æ** %d x üÉè **%s** (ID –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –∏ –ø—Ä–æ–¥–∞–∂–∏: %s) –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é <@%s>.", count, nft.Name, nftID, userID))
}

// HandleAdminRemoveNFT !a_remove_nft <@user> <nftID> <count>
func (r *Ranking) HandleAdminRemoveNFT(s *discordgo.Session, m *discordgo.MessageCreate, command string) {
	if len(m.Mentions) != 1 {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–£–ø–æ–º—è–Ω–∏—Ç–µ –æ–¥–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è**: !a_remove_nft @user <nftID> <count>")
		return
	}
	userID := m.Mentions[0].ID
	parts := strings.Fields(command)
	if len(parts) != 4 {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ**: !a_remove_nft @user <nftID> <count>")
		return
	}
	nftID, countStr := parts[2], parts[3]
	count, err := strconv.Atoi(countStr)
	if err != nil || count <= 0 {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ.**")
		return
	}

	// –ü—Ä–æ–≤–µ—Ä–∫–∞ NFT
	nft, ok := r.Kki.nfts[nftID]
	if !ok {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **NFT –Ω–µ –Ω–∞–π–¥–µ–Ω–æ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ ID.**")
		return
	}

	inv := r.GetUserInventory(userID)
	if inv[nftID] < count {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ NFT.**")
		return
	}
	inv[nftID] -= count
	if inv[nftID] == 0 {
		delete(inv, nftID)
	}
	r.SaveUserInventory(userID, inv)

	s.ChannelMessageSend(m.ChannelID, fmt.Sprintf("‚úÖ **–£–¥–∞–ª–µ–Ω–æ** %d x üÉè **%s** (ID –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –∏ –ø—Ä–æ–¥–∞–∂–∏: %s) —É <@%s>.", count, nft.Name, nftID, userID))
}

// HandleAdminHolidayCase !a_holiday_case <@user> <count>
func (r *Ranking) HandleAdminHolidayCase(s *discordgo.Session, m *discordgo.MessageCreate, command string) {
	if len(m.Mentions) != 1 {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–£–ø–æ–º—è–Ω–∏—Ç–µ –æ–¥–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è**: !a_holiday_case @user <count>")
		return
	}
	userID := m.Mentions[0].ID
	parts := strings.Fields(command)
	if len(parts) != 3 {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ**: !a_holiday_case @user <count>")
		return
	}
	count, err := strconv.Atoi(parts[2])
	if err != nil || count <= 0 {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ.**")
		return
	}

	inv := r.Kki.GetUserCaseInventory(r, userID)
	inv["holiday_case"] += count
	r.Kki.SaveUserCaseInventory(r, userID, inv)

	s.ChannelMessageSend(m.ChannelID, fmt.Sprintf("‚úÖ **–í—ã–¥–∞–Ω–æ** %d x üì¶ **–ü—Ä–∞–∑–¥–Ω–∏—á–Ω—ã–π –∫–µ–π—Å** (ID –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è/–ø–µ—Ä–µ–¥–∞—á–∏: holiday_case) –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é <@%s>.", count, userID))
}

// HandleShowNFTCommand !show_nft <nftID>
func (r *Ranking) HandleShowNFTCommand(s *discordgo.Session, m *discordgo.MessageCreate, command string) {
	parts := strings.Fields(command)
	if len(parts) != 2 {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ**: !nft_show <nftID>")
		return
	}
	nftID := parts[1]
	nft, ok := r.Kki.nfts[nftID]
	if !ok {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **NFT –Ω–µ –Ω–∞–π–¥–µ–Ω–æ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ ID.**")
		return
	}

	embed := &discordgo.MessageEmbed{
		Title:       fmt.Sprintf("üÉè %s **%s**", RarityEmojis[nft.Rarity], nft.Name),
		Description: fmt.Sprintf("**ID –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –∏ –ø—Ä–æ–¥–∞–∂–∏**: %s\n**–û–ø–∏—Å–∞–Ω–∏–µ**: %s\n**–†–µ–¥–∫–æ—Å—Ç—å**: %s\n**–î–∞—Ç–∞ –≤—ã–ø—É—Å–∫–∞**: %s\n**–¶–µ–Ω–∞**: üí∞ %d\n**–ö–æ–ª–ª–µ–∫—Ü–∏—è**: %s", nftID, nft.Description, nft.Rarity, nft.ReleaseDate, nft.Price, nft.Collection),
		Color:       RarityColors[nft.Rarity],
		Image:       &discordgo.MessageEmbedImage{URL: nft.ImageURL},
		Footer:      &discordgo.MessageEmbedFooter{Text: fmt.Sprintf("–ü–æ—Ö–≤–∞—Å—Ç–∞–ª—Å—è: %s | –°–ª–∞–≤—å –ò–º–ø–µ—Ä–∞—Ç–æ—Ä–∞! üëë", m.Author.Username)},
	}
	s.ChannelMessageSendEmbed(m.ChannelID, embed)
}

// ClearAllUserNFTs –æ—á–∏—â–∞–µ—Ç –≤—Å–µ NFT –∏ –∫–µ–π—Å—ã –¥–ª—è —Ç–µ—Å—Ç–∞
func (r *Ranking) ClearAllUserNFTs(s *discordgo.Session, m *discordgo.MessageCreate) {
	keys, _ := r.redis.Keys(r.ctx, "inventory:*").Result()
	for _, key := range keys {
		r.redis.Del(r.ctx, key)
	}
	keys, _ = r.redis.Keys(r.ctx, "case_inventory:*").Result()
	for _, key := range keys {
		r.redis.Del(r.ctx, key)
	}
	keys, _ = r.redis.Keys(r.ctx, "case_limit:*").Result()
	for _, key := range keys {
		r.redis.Del(r.ctx, key)
	}
	keys, _ = r.redis.Keys(r.ctx, "daily_case:*").Result()
	for _, key := range keys {
		r.redis.Del(r.ctx, key)
	}
	keys, _ = r.redis.Keys(r.ctx, "case_buy_limit:*").Result()
	for _, key := range keys {
		r.redis.Del(r.ctx, key)
	}
	// –°–±—Ä–æ—Å –±–∞–Ω–∫–∞ –∫–µ–π—Å–æ–≤
	r.initializeCaseBank()

	s.ChannelMessageSend(m.ChannelID, "‚ùå **–í—Å–µ NFT, –∫–µ–π—Å—ã, –ª–∏–º–∏—Ç—ã –∏ –±–∞–Ω–∫ –∫–µ–π—Å–æ–≤ –æ—á–∏—â–µ–Ω—ã.**")
}

// HandleCaseInventoryCommand –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å –∫–µ–π—Å–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –ª–∏–º–∏—Ç –æ—Ç–∫—Ä—ã—Ç–∏—è
func (r *Ranking) HandleCaseInventoryCommand(s *discordgo.Session, m *discordgo.MessageCreate) {
	inv := r.Kki.GetUserCaseInventory(r, m.Author.ID)
	if len(inv) == 0 {
		s.ChannelMessageSend(m.ChannelID, "üì¶ **–ò–Ω–≤–µ–Ω—Ç–∞—Ä—å –∫–µ–π—Å–æ–≤ –ø—É—Å—Ç** ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n–ò–º–ø–µ—Ä–∞—Ç–æ—Ä –∂–¥—ë—Ç, –æ—Ç–∫—Ä—ã–≤–∞–π –∫–µ–π—Å—ã! üò§")
		return
	}

	var lines []string
	for caseID, count := range inv {
		// –£–Ω–∏—Ñ–∏–∫–∞—Ü–∏—è daily_case
		displayID := caseID
		if caseID == "daily_case" {
			displayID = "daily_case"
		}
		kase, ok := r.Kki.cases[caseID]
		if !ok {
			log.Printf("Case %s not found in r.Kki.cases for user %s", caseID, m.Author.ID)
			continue
		}
		lines = append(lines, fmt.Sprintf("üì¶ **%s** (x%d)\nüìå ID –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è/–ø–µ—Ä–µ–¥–∞—á–∏: %s\nüí∞ –¶–µ–Ω–∞: %d", kase.Name, count, displayID, kase.Price))
	}
	if len(lines) == 0 {
		s.ChannelMessageSend(m.ChannelID, "üì¶ **–ò–Ω–≤–µ–Ω—Ç–∞—Ä—å –∫–µ–π—Å–æ–≤ –ø—É—Å—Ç** ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n–ò–º–ø–µ—Ä–∞—Ç–æ—Ä –∂–¥—ë—Ç, –æ—Ç–∫—Ä—ã–≤–∞–π –∫–µ–π—Å—ã! üò§")
		return
	}
	sort.Strings(lines)

	// –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–Ω–µ–≤–Ω–æ–≥–æ –ª–∏–º–∏—Ç–∞
	key := fmt.Sprintf("case_limit:%s:%s", m.Author.ID, time.Now().Format("2006-01-02"))
	opened, _ := r.redis.Get(r.ctx, key).Int()
	limitMsg := fmt.Sprintf("üîÑ **–õ–∏–º–∏—Ç –æ—Ç–∫—Ä—ã—Ç–∏—è –∫–µ–π—Å–æ–≤ —Å–µ–≥–æ–¥–Ω—è**: %d/5", opened)

	embed := &discordgo.MessageEmbed{
		Title:       "üì¶ **–ò–Ω–≤–µ–Ω—Ç–∞—Ä—å –∫–µ–π—Å–æ–≤** ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê",
		Description: strings.Join(lines, "\n\n") + "\n" + limitMsg,
		Color:       0x00BFFF,
		Footer:      &discordgo.MessageEmbedFooter{Text: fmt.Sprintf("–í–ª–∞–¥–µ–ª–µ—Ü: %s | –°–ª–∞–≤—å –ò–º–ø–µ—Ä–∞—Ç–æ—Ä–∞! üëë", m.Author.Username)},
	}
	s.ChannelMessageSendEmbed(m.ChannelID, embed)
}

// HandleAdminGiveHolidayCaseAll !a_give_holiday_case_all <count>
func (r *Ranking) HandleAdminGiveHolidayCaseAll(s *discordgo.Session, m *discordgo.MessageCreate, command string) {
	if !r.IsAdmin(m.Author.ID) {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω—ã –º–æ–≥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç—É –∫–æ–º–∞–Ω–¥—É!**")
		return
	}
	parts := strings.Fields(command)
	if len(parts) != 2 {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ**: !a_give_holiday_case_all <count>")
		return
	}
	count, err := strconv.Atoi(parts[1])
	if err != nil || count <= 0 {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ.**")
		return
	}

	// –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è holiday_case
	if _, ok := r.Kki.cases["holiday_case"]; !ok {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–ü—Ä–∞–∑–¥–Ω–∏—á–Ω—ã–π –∫–µ–π—Å (ID: holiday_case) –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –±–∞–∑–µ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ Google Sheets.**")
		log.Printf("holiday_case not found in r.Kki.cases")
		return
	}

	// –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –≥–∏–ª—å–¥–∏–∏
	guild, err := s.Guild(m.GuildID)
	if err != nil {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∞ –±–æ—Ç–∞ (View Guild Members).**")
		log.Printf("Failed to fetch guild members: %v", err)
		return
	}

	if len(guild.Members) == 0 {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–ì–∏–ª—å–¥–∏—è –ø—É—Å—Ç–∞ –∏–ª–∏ –±–æ—Ç –Ω–µ –º–æ–∂–µ—Ç –ø–æ–ª—É—á–∏—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∞.**")
		log.Printf("No members found in guild %s", m.GuildID)
		return
	}

	successCount := 0
	for _, member := range guild.Members {
		if member.User.Bot {
			log.Printf("Skipping bot user %s", member.User.ID)
			continue
		}
		inv := r.Kki.GetUserCaseInventory(r, member.User.ID)
		inv["holiday_case"] += count
		err := r.Kki.SaveUserCaseInventory(r, member.User.ID, inv)
		if err != nil {
			log.Printf("Failed to save case inventory for user %s: %v", member.User.ID, err)
			continue
		}
		successCount++
		log.Printf("Added %d holiday_case to user %s", count, member.User.ID)
	}

	if successCount == 0 {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–¥–∞—Ç—å –∫–µ–π—Å—ã –Ω–∏ –æ–¥–Ω–æ–º—É —É—á–∞—Å—Ç–Ω–∏–∫—É. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏ –∏ –ø—Ä–∞–≤–∞ –±–æ—Ç–∞.**")
		log.Printf("No holiday cases distributed in guild %s", m.GuildID)
		return
	}

	s.ChannelMessageSend(m.ChannelID, fmt.Sprintf("‚úÖ **–í—ã–¥–∞–Ω–æ** %d x üì¶ **–ü—Ä–∞–∑–¥–Ω–∏—á–Ω—ã–π –∫–µ–π—Å** (ID –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è/–ø–µ—Ä–µ–¥–∞—á–∏: holiday_case) %d —É—á–∞—Å—Ç–Ω–∏–∫–∞–º —Å–µ—Ä–≤–µ—Ä–∞!", count, successCount))
}

// HandleCaseHelpCommand !case_help - –æ–±–Ω–æ–≤–ª–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è
func (r *Ranking) HandleCaseHelpCommand(s *discordgo.Session, m *discordgo.MessageCreate) {
	embed := &discordgo.MessageEmbed{
		Title:       "üì¶ **–ü–æ–º–æ—â—å –ø–æ –∫–µ–π—Å–∞–º, NFT –∏ —ç–∫–æ–Ω–æ–º–∏–∫–µ** ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê",
		Description: "–°–ª–∞–≤—å –ò–º–ø–µ—Ä–∞—Ç–æ—Ä–∞! üëë –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è —ç–∫–æ–Ω–æ–º–∏–∫–∞ –ø—Ä–∏–≤—è–∑–∞–Ω–∞ –∫ –∫—É—Ä—Å—É BTC",
		Color:       0xFFD700,
		Fields: []*discordgo.MessageEmbedField{
			{
				Name:   "üí∞ **–≠–∫–æ–Ω–æ–º–∏–∫–∞ –∏ —Ü–µ–Ω—ã**",
				Value:  "```!btc - –¢–µ–∫—É—â–∏–π –∫—É—Ä—Å –±–∏—Ç–∫–æ–π–Ω–∞\n!prices - –î–∏–Ω–∞–º–∏–∫–∞ —Ü–µ–Ω –ø–æ —Ä–µ–¥–∫–æ—Å—Ç—è–º\n!price_stats - –ü–æ–¥—Ä–æ–±–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ü–µ–Ω```",
				Inline: true,
			},
			{
				Name:   "üì¶ **–ö–µ–π—Å—ã –∏ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å**",
				Value:  "```!case_inventory - –ú–æ–∏ –∫–µ–π—Å—ã\n!open_case <ID> - –û—Ç–∫—Ä—ã—Ç—å –∫–µ–π—Å\n!daily_case - –ï–∂–µ–¥–Ω–µ–≤–Ω—ã–π –∫–µ–π—Å\n!case_bank - –ö–µ–π—Å—ã –≤ –±–∞–Ω–∫–µ\n!buy_case_bank <ID> <count> - –ö—É–ø–∏—Ç—å –∏–∑ –±–∞–Ω–∫–∞\n!case_trade @user <ID> <count> - –ö—É–ø–∏—Ç—å —É –∏–≥—Ä–æ–∫–∞```",
				Inline: true,
			},
			{
				Name:   "üÉè **NFT –∏ —Ç–æ—Ä–≥–æ–≤–ª—è**",
				Value:  "```!inventory - –ú–æ–∏ NFT\n!nft_show <ID> - –ü–æ–∫–∞–∑–∞—Ç—å NFT\n!sell <ID> <count> - –ü—Ä–æ–¥–∞—Ç—å NFT\n!trade_nft @user <ID> <count> - –ü–µ—Ä–µ–¥–∞—Ç—å NFT\n!market - –†—ã–Ω–æ—á–Ω—ã–µ —Ü–µ–Ω—ã (—Å–∫–æ—Ä–æ)```",
				Inline: true,
			},
			{
				Name:   "üëë **–ê–¥–º–∏–Ω—Å–∫–∏–µ –∫–æ–º–∞–Ω–¥—ã**",
				Value:  "```!sync_nfts - –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å Sheets\n!a_give_case @user <ID> - –í—ã–¥–∞—Ç—å –∫–µ–π—Å\n!a_give_nft @user <ID> <count> - –í—ã–¥–∞—Ç—å NFT\n!a_remove_nft @user <ID> <count> - –£–¥–∞–ª–∏—Ç—å NFT\n!a_refresh_bank - –û–±–Ω–æ–≤–∏—Ç—å –±–∞–Ω–∫ –∫–µ–π—Å–æ–≤\n!a_reset_case_limits - –°–±—Ä–æ—Å–∏—Ç—å –ª–∏–º–∏—Ç—ã\n!test_clear_all_nfts - –û—á–∏—Å—Ç–∏—Ç—å –≤—Å—ë```",
				Inline: false,
			},
		},
		Footer: &discordgo.MessageEmbedFooter{
			Text: fmt.Sprintf("–í—ã–∑–≤–∞–ª: %s | –†–µ–¥–∫–∏–µ NFT –∑–∞–≤–∏—Å—è—Ç –æ—Ç –∫—É—Ä—Å–∞ BTC!", m.Author.Username),
		},
	}
	s.ChannelMessageSendEmbed(m.ChannelID, embed)
}

// initializeCaseBank –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç –±–∞–Ω–∫ –∫–µ–π—Å–æ–≤ —Å–ª—É—á–∞–π–Ω—ã–º–∏ –∫–µ–π—Å–∞–º–∏
func (r *Ranking) initializeCaseBank() {
	r.mu.Lock()
	defer r.mu.Unlock()

	// –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –∫–µ–π—Å—ã
	allCases := make([]string, 0, len(r.Kki.cases))
	for caseID := range r.Kki.cases {
		allCases = append(allCases, caseID)
	}

	// –í—ã–±–∏—Ä–∞–µ–º 2 —Å–ª—É—á–∞–π–Ω—ã—Ö –∫–µ–π—Å–∞
	if len(allCases) > 0 {
		rand.Seed(time.Now().UnixNano())
		rand.Shuffle(len(allCases), func(i, j int) {
			allCases[i], allCases[j] = allCases[j], allCases[i]
		})

		numToSelect := min(2, len(allCases))
		selectedCases := allCases[:numToSelect]

		newCases := make(map[string]int)
		for _, caseID := range selectedCases {
			newCases[caseID] = 70
		}

		r.caseBank = &CaseBank{
			Cases:       newCases,
			LastUpdated: time.Now(),
		}

		jsonData, _ := json.Marshal(r.caseBank)
		r.redis.Set(r.ctx, "case_bank", jsonData, 0)
		log.Printf("Case bank initialized with: %v", selectedCases)
	} else {
		// Fallback –µ—Å–ª–∏ –∫–µ–π—Å–æ–≤ –Ω–µ—Ç
		r.caseBank = &CaseBank{
			Cases:       make(map[string]int),
			LastUpdated: time.Now(),
		}
		log.Printf("Case bank initialized empty - no cases available")
	}
}

// HandleAdminRefreshBankCommand !a_refresh_bank
func (r *Ranking) HandleAdminRefreshBankCommand(s *discordgo.Session, m *discordgo.MessageCreate) {
	if !r.IsAdmin(m.Author.ID) {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω—ã –º–æ–≥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç—É –∫–æ–º–∞–Ω–¥—É!**")
		return
	}

	// –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ–±–Ω–æ–≤–ª—è–µ–º –±–∞–Ω–∫
	r.mu.Lock()
	defer r.mu.Unlock()

	// –ü–æ–ª—É—á–∞–µ–º –í–°–ï –¥–æ—Å—Ç—É–ø–Ω—ã–µ –∫–µ–π—Å—ã –∏–∑ —Ç–∞–±–ª–∏—Ü—ã
	allCases := make([]string, 0, len(r.Kki.cases))
	for caseID := range r.Kki.cases {
		allCases = append(allCases, caseID)
	}

	// –†–∞–Ω–¥–æ–º–Ω–æ –≤—ã–±–∏—Ä–∞–µ–º 2 –∫–µ–π—Å–∞
	if len(allCases) < 2 {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–í —Ç–∞–±–ª–∏—Ü–µ –º–µ–Ω—å—à–µ 2 –∫–µ–π—Å–æ–≤!**")
		return
	}

	// –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–µ–º –∏ –≤—ã–±–∏—Ä–∞–µ–º 2 —Å–ª—É—á–∞–π–Ω—ã—Ö –∫–µ–π—Å–∞
	rand.Seed(time.Now().UnixNano())
	rand.Shuffle(len(allCases), func(i, j int) {
		allCases[i], allCases[j] = allCases[j], allCases[i]
	})
	selectedCases := allCases[:2]

	// –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ 70 —à—Ç—É–∫ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –∫–µ–π—Å–∞
	newCases := make(map[string]int)
	for _, caseID := range selectedCases {
		newCases[caseID] = 70
	}

	r.caseBank.Cases = newCases
	r.caseBank.LastUpdated = time.Now()

	// –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ Redis
	jsonData, _ := json.Marshal(r.caseBank)
	r.redis.Set(r.ctx, "case_bank", jsonData, 0)

	// –§–æ—Ä–º–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –∫–µ–π—Å–æ–≤ –¥–ª—è –æ—Ç–≤–µ—Ç–∞
	var caseList []string
	for _, caseID := range selectedCases {
		kase := r.Kki.cases[caseID]
		caseList = append(caseList, fmt.Sprintf("üì¶ **%s** (ID: `%s`)", kase.Name, caseID))
	}

	embed := &discordgo.MessageEmbed{
		Title: "üîÑ **–ë–∞–Ω–∫ –∫–µ–π—Å–æ–≤ –æ–±–Ω–æ–≤–ª–µ–Ω!**",
		Description: fmt.Sprintf("–í—ã–±—Ä–∞–Ω—ã —Å–ª—É—á–∞–π–Ω—ã–µ –∫–µ–π—Å—ã:\n%s\n\n–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: **70** –∫–∞–∂–¥–æ–≥–æ\n–û–±–Ω–æ–≤–ª–µ–Ω–æ: %s",
			strings.Join(caseList, "\n"), time.Now().Format("15:04:05")),
		Color:  0x00FF00,
		Footer: &discordgo.MessageEmbedFooter{Text: "–ò–º–ø–µ—Ä–∞—Ç–æ—Ä –æ–¥–æ–±—Ä—è–µ—Ç —Å–ª—É—á–∞–π–Ω—ã–π –≤—ã–±–æ—Ä!"},
	}

	s.ChannelMessageSendEmbed(m.ChannelID, embed)
	log.Printf("–ë–∞–Ω–∫ –∫–µ–π—Å–æ–≤ –æ–±–Ω–æ–≤–ª–µ–Ω –≤—Ä—É—á–Ω—É—é: %v", selectedCases)
}

// refreshCaseBank –æ–±–Ω–æ–≤–ª—è–µ—Ç –±–∞–Ω–∫ –∫–µ–π—Å–æ–≤ —Å–ª—É—á–∞–π–Ω—ã–º–∏ –∫–µ–π—Å–∞–º–∏ –∏–∑ —Ç–∞–±–ª–∏—Ü—ã
func (r *Ranking) refreshCaseBank() {
	r.mu.Lock()
	defer r.mu.Unlock()

	// –ó–∞–≥—Ä—É–∂–∞–µ–º —Ç–µ–∫—É—â–∏–π –±–∞–Ω–∫ –∏–∑ Redis
	jsonData, err := r.redis.Get(r.ctx, "case_bank").Bytes()
	if err == redis.Nil {
		r.initializeCaseBank()
		return
	}
	var bank CaseBank
	if err := json.Unmarshal(jsonData, &bank); err != nil {
		log.Printf("Failed to unmarshal case_bank: %v", err)
		r.initializeCaseBank()
		return
	}
	r.caseBank = &bank

	// –û–±–Ω–æ–≤–ª—è–µ–º –µ—Å–ª–∏ –ø—Ä–æ—à–ª–æ 12 —á–∞—Å–æ–≤ –ò–õ–ò –µ—Å–ª–∏ –±–∞–Ω–∫ –ø—É—Å—Ç–æ–π
	if time.Since(r.caseBank.LastUpdated) >= 12*time.Hour || len(r.caseBank.Cases) == 0 {
		// –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –∫–µ–π—Å—ã –∏–∑ —Ç–∞–±–ª–∏—Ü—ã
		allCases := make([]string, 0, len(r.Kki.cases))
		for caseID := range r.Kki.cases {
			allCases = append(allCases, caseID)
		}

		// –†–∞–Ω–¥–æ–º–Ω–æ –≤—ã–±–∏—Ä–∞–µ–º 2 –∫–µ–π—Å–∞ (–µ—Å–ª–∏ –º–µ–Ω—å—à–µ 2, –≤—ã–±–∏—Ä–∞–µ–º –≤—Å–µ)
		numToSelect := 2
		if len(allCases) < numToSelect {
			numToSelect = len(allCases)
		}

		// –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–µ–º –º–∞—Å—Å–∏–≤
		rand.Seed(time.Now().UnixNano())
		rand.Shuffle(len(allCases), func(i, j int) {
			allCases[i], allCases[j] = allCases[j], allCases[i]
		})
		selectedCases := allCases[:numToSelect]

		// –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ 70 —à—Ç—É–∫ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –∫–µ–π—Å–∞
		newCases := make(map[string]int)
		for _, caseID := range selectedCases {
			newCases[caseID] = 50
		}

		r.caseBank.Cases = newCases
		r.caseBank.LastUpdated = time.Now()

		jsonData, _ := json.Marshal(r.caseBank)
		r.redis.Set(r.ctx, "case_bank", jsonData, 0)
		log.Printf("Case bank refreshed at %s with cases: %v", time.Now(), selectedCases)
	}
}

// randomShuffle –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–µ—Ä–µ–º–µ—à–∞–Ω–Ω—ã–π —Å–ª–∞–π—Å (Go –Ω–µ –∏–º–µ–µ—Ç –≤—Å—Ç—Ä–æ–µ–Ω–Ω–æ–≥–æ random.shuffle)
func randomShuffle(slice []string) []string {
	n := len(slice)
	rand.Seed(time.Now().UnixNano())
	for i := n - 1; i > 0; i-- {
		j := rand.Intn(i + 1)
		slice[i], slice[j] = slice[j], slice[i]
	}
	return slice
}

// HandleCaseBankCommand !case_bank
func (r *Ranking) HandleCaseBankCommand(s *discordgo.Session, m *discordgo.MessageCreate) {
	r.refreshCaseBank()

	var lines []string
	for caseID, count := range r.caseBank.Cases {
		kase, ok := r.Kki.cases[caseID]
		if !ok {
			continue
		}
		lines = append(lines, fmt.Sprintf("üì¶ **%s** (x%d)\nüìå ID: %s\nüí∞ –¶–µ–Ω–∞: %d", kase.Name, count, caseID, kase.Price))
	}
	if len(lines) == 0 {
		s.ChannelMessageSend(m.ChannelID, "üè¶ **–ë–∞–Ω–∫ –∫–µ–π—Å–æ–≤ –ø—É—Å—Ç** ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n–ò–º–ø–µ—Ä–∞—Ç–æ—Ä –∂–¥—ë—Ç –Ω–æ–≤—ã—Ö –ø–æ—Å—Ç–∞–≤–æ–∫! üò¢")
		return
	}

	nextUpdate := r.caseBank.LastUpdated.Add(12 * time.Hour)
	timeLeft := time.Until(nextUpdate).Round(time.Second)
	hours := int(timeLeft.Hours())
	minutes := int(timeLeft.Minutes()) % 60
	timeLeftStr := fmt.Sprintf("%d—á %d–º", hours, minutes)

	embed := &discordgo.MessageEmbed{
		Title:       "üè¶ **–ë–∞–Ω–∫ –∫–µ–π—Å–æ–≤** ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê",
		Description: fmt.Sprintf("–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–µ–π—Å—ã –¥–ª—è –ø–æ–∫—É–ø–∫–∏:\n\n%s\n\nüïí **–î–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –º–∞–≥–∞–∑–∏–Ω–∞**: %s", strings.Join(lines, "\n\n"), timeLeftStr),
		Color:       0x00BFFF,
		Footer:      &discordgo.MessageEmbedFooter{Text: fmt.Sprintf("–í—ã–∑–≤–∞–ª: %s | –°–ª–∞–≤—å –ò–º–ø–µ—Ä–∞—Ç–æ—Ä–∞! üëë", m.Author.Username)},
	}
	s.ChannelMessageSendEmbed(m.ChannelID, embed)
}

// HandleBuyCaseBankCommand !buy_case_bank <caseID> <count>
func (r *Ranking) HandleBuyCaseBankCommand(s *discordgo.Session, m *discordgo.MessageCreate, command string) {
	parts := strings.Fields(command)
	if len(parts) != 3 {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ**: !buy_case_bank <caseID> <count>")
		return
	}
	caseID, countStr := parts[1], parts[2]
	count, err := strconv.Atoi(countStr)
	if err != nil || count <= 0 {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ.**")
		return
	}

	// –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–µ–π—Å–∞
	kase, ok := r.Kki.cases[caseID]
	if !ok {
		s.ChannelMessageSend(m.ChannelID, fmt.Sprintf("‚ùå **–ö–µ–π—Å —Å ID %s –Ω–µ –Ω–∞–π–¥–µ–Ω.**", caseID))
		return
	}

	// –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–∞–Ω–∫–∞
	r.refreshCaseBank()
	if r.caseBank.Cases[caseID] < count {
		s.ChannelMessageSend(m.ChannelID, fmt.Sprintf("‚ùå **–í –±–∞–Ω–∫–µ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫–µ–π—Å–æ–≤ (%s). –û—Å—Ç–∞—Ç–æ–∫: %d.**", kase.Name, r.caseBank.Cases[caseID]))
		return
	}

	// –ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏–º–∏—Ç–∞ –ø–æ–∫—É–ø–æ–∫
	key := fmt.Sprintf("case_buy_limit:%s:%s", m.Author.ID, time.Now().Format("2006-01-02"))
	bought, _ := r.redis.Get(r.ctx, key).Int()
	if bought+count > 5 {
		s.ChannelMessageSend(m.ChannelID, fmt.Sprintf("‚ùå **–î–æ—Å—Ç–∏–≥–Ω—É—Ç –¥–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç –ø–æ–∫—É–ø–æ–∫ (5 –∫–µ–π—Å–æ–≤). –ö—É–ø–ª–µ–Ω–æ —Å–µ–≥–æ–¥–Ω—è: %d.**", bought))
		return
	}

	// –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—Ä–µ–¥–∏—Ç–æ–≤
	price := kase.Price * count
	buyerCoins := r.GetRating(m.Author.ID)
	if buyerCoins < price {
		s.ChannelMessageSend(m.ChannelID, fmt.Sprintf("‚ùå **–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫—Ä–µ–¥–∏—Ç–æ–≤. –ù—É–∂–Ω–æ: %d, —É –≤–∞—Å: %d.**", price, buyerCoins))
		return
	}

	// –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–∞–Ω–∫–∞
	r.mu.Lock()
	r.caseBank.Cases[caseID] -= count
	if r.caseBank.Cases[caseID] == 0 {
		delete(r.caseBank.Cases, caseID)
	}
	jsonData, _ := json.Marshal(r.caseBank)
	r.redis.Set(r.ctx, "case_bank", jsonData, 0)
	r.mu.Unlock()

	// –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è
	buyerInv := r.Kki.GetUserCaseInventory(r, m.Author.ID)
	buyerInv[caseID] += count
	err = r.Kki.SaveUserCaseInventory(r, m.Author.ID, buyerInv)
	if err != nil {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.**")
		log.Printf("Failed to save case inventory for user %s: %v", m.Author.ID, err)
		return
	}

	// –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—Ä–µ–¥–∏—Ç–æ–≤
	r.UpdateRating(m.Author.ID, -price)
	r.redis.IncrBy(r.ctx, key, int64(count))
	r.redis.Expire(r.ctx, key, 24*time.Hour)

	// –õ–æ–≥ –æ–ø–µ—Ä–∞—Ü–∏–∏
	r.LogCreditOperation(s, fmt.Sprintf("üõí **%s** –∫—É–ø–∏–ª %d x üì¶ **%s** (ID: %s) –∏–∑ –±–∞–Ω–∫–∞ –∑–∞ üí∞ %d –∫—Ä–µ–¥–∏—Ç–æ–≤.", m.Author.Username, count, kase.Name, caseID, price))

	s.ChannelMessageSend(m.ChannelID, fmt.Sprintf("‚úÖ **–ö—É–ø–ª–µ–Ω–æ** %d x üì¶ **%s** (ID: %s) –∑–∞ üí∞ %d –∫—Ä–µ–¥–∏—Ç–æ–≤!", count, kase.Name, caseID, price))
}

// HandleResetCaseLimitsCommand !a_reset_case_limits
func (r *Ranking) HandleResetCaseLimitsCommand(s *discordgo.Session, m *discordgo.MessageCreate) {
	if !r.IsAdmin(m.Author.ID) {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω—ã –º–æ–≥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç—É –∫–æ–º–∞–Ω–¥—É!**")
		return
	}

	totalDeleted := 0

	// –°–±—Ä–æ—Å –ª–∏–º–∏—Ç–æ–≤ –Ω–∞ –æ—Ç–∫—Ä—ã—Ç–∏–µ –∫–µ–π—Å–æ–≤
	keys, err := r.redis.Keys(r.ctx, "case_limit:*").Result()
	if err != nil {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–ª—é—á–µ–π case_limit –∏–∑ Redis.**")
		log.Printf("Failed to get case_limit keys: %v", err)
		return
	}
	for _, key := range keys {
		r.redis.Del(r.ctx, key)
		log.Printf("Deleted case limit key: %s", key)
		totalDeleted++
	}

	// –°–±—Ä–æ—Å –ª–∏–º–∏—Ç–æ–≤ –Ω–∞ –ø–æ–∫—É–ø–∫—É –∫–µ–π—Å–æ–≤
	keys, err = r.redis.Keys(r.ctx, "case_buy_limit:*").Result()
	if err != nil {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–ª—é—á–µ–π case_buy_limit –∏–∑ Redis.**")
		log.Printf("Failed to get case_buy_limit keys: %v", err)
		return
	}
	for _, key := range keys {
		r.redis.Del(r.ctx, key)
		log.Printf("Deleted case buy limit key: %s", key)
		totalDeleted++
	}

	// –°–±—Ä–æ—Å –ª–∏–º–∏—Ç–æ–≤ –Ω–∞ –µ–∂–µ–¥–Ω–µ–≤–Ω—ã–π –∫–µ–π—Å
	keys, err = r.redis.Keys(r.ctx, "daily_case:*").Result()
	if err != nil {
		s.ChannelMessageSend(m.ChannelID, "‚ùå **–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–ª—é—á–µ–π daily_case –∏–∑ Redis.**")
		log.Printf("Failed to get daily_case keys: %v", err)
		return
	}
	for _, key := range keys {
		r.redis.Del(r.ctx, key)
		log.Printf("Deleted daily case key: %s", key)
		totalDeleted++
	}

	if totalDeleted == 0 {
		s.ChannelMessageSend(m.ChannelID, "‚ÑπÔ∏è **–õ–∏–º–∏—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –¥–ª—è —Å–±—Ä–æ—Å–∞. –í–æ–∑–º–æ–∂–Ω–æ, –æ–Ω–∏ —É–∂–µ –±—ã–ª–∏ —Å–±—Ä–æ—à–µ–Ω—ã –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤ 4:00 –ø–æ –ö—Ä–∞—Å–Ω–æ—è—Ä—Å–∫—É.**")
		log.Printf("No limits found to reset for command !a_reset_case_limits")
		return
	}

	s.ChannelMessageSend(m.ChannelID, fmt.Sprintf("‚úÖ **–°–±—Ä–æ—à–µ–Ω–æ %d –ª–∏–º–∏—Ç–æ–≤ (–æ—Ç–∫—Ä—ã—Ç–∏–µ, –ø–æ–∫—É–ø–∫–∞, –µ–∂–µ–¥–Ω–µ–≤–Ω—ã–π –∫–µ–π—Å) –¥–ª—è –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π!**", totalDeleted))
	log.Printf("Reset %d limits for all users", totalDeleted)
}

// startDailyReset –∑–∞–ø—É—Å–∫–∞–µ—Ç –≥–æ—Ä—É—Ç–∏–Ω—É –¥–ª—è —Å–±—Ä–æ—Å–∞ –ª–∏–º–∏—Ç–æ–≤ –≤ 4:00 –ø–æ –ö—Ä–∞—Å–Ω–æ—è—Ä—Å–∫—É
func (r *Ranking) startDailyReset() {
	// –ó–∞–≥—Ä—É–∂–∞–µ–º —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å –ö—Ä–∞—Å–Ω–æ—è—Ä—Å–∫–∞
	loc, err := time.LoadLocation("Asia/Krasnoyarsk")
	if err != nil {
		log.Printf("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —á–∞—Å–æ–≤–æ–≥–æ –ø–æ—è—Å–∞ Asia/Krasnoyarsk: %v", err)
		return
	}

	for {
		// –í—ã—á–∏—Å–ª—è–µ–º –≤—Ä–µ–º—è –¥–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ —Å–±—Ä–æ—Å–∞ (4:00 —Å–ª–µ–¥—É—é—â–µ–≥–æ –¥–Ω—è)
		now := time.Now().In(loc)
		nextReset := time.Date(now.Year(), now.Month(), now.Day(), 4, 0, 0, 0, loc)
		if now.After(nextReset) || now.Equal(nextReset) {
			nextReset = nextReset.Add(24 * time.Hour)
		}
		timeUntilReset := nextReset.Sub(now)

		// –û–∂–∏–¥–∞–µ–º –¥–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ —Å–±—Ä–æ—Å–∞ –∏–ª–∏ —Å–∏–≥–Ω–∞–ª–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏
		select {
		case <-time.After(timeUntilReset):
			// –í—ã–ø–æ–ª–Ω—è–µ–º —Å–±—Ä–æ—Å –≤—Å–µ—Ö –ª–∏–º–∏—Ç–æ–≤
			r.resetAllLimits()
			log.Printf("–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Å–±—Ä–æ—Å –ª–∏–º–∏—Ç–æ–≤ –≤—ã–ø–æ–ª–Ω–µ–Ω –≤ %s", time.Now().In(loc).Format(time.RFC3339))
		case <-r.stopResetChan:
			log.Printf("–ì–æ—Ä—É—Ç–∏–Ω–∞ —Å–±—Ä–æ—Å–∞ –ª–∏–º–∏—Ç–æ–≤ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞")
			return
		}
	}
}

// resetAllLimits —Å–±—Ä–∞—Å—ã–≤–∞–µ—Ç –≤—Å–µ –ª–∏–º–∏—Ç—ã (–æ—Ç–∫—Ä—ã—Ç–∏–µ, –ø–æ–∫—É–ø–∫–∞, –µ–∂–µ–¥–Ω–µ–≤–Ω—ã–π –∫–µ–π—Å)
func (r *Ranking) resetAllLimits() {
	r.mu.Lock()
	defer r.mu.Unlock()

	// –°–±—Ä–æ—Å –ª–∏–º–∏—Ç–æ–≤ –Ω–∞ –æ—Ç–∫—Ä—ã—Ç–∏–µ –∫–µ–π—Å–æ–≤
	keys, err := r.redis.Keys(r.ctx, "case_limit:*").Result()
	if err != nil {
		log.Printf("–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–ª—é—á–µ–π case_limit: %v", err)
		return
	}
	for _, key := range keys {
		r.redis.Del(r.ctx, key)
		log.Printf("–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —É–¥–∞–ª–µ–Ω –∫–ª—é—á case_limit: %s", key)
	}

	// –°–±—Ä–æ—Å –ª–∏–º–∏—Ç–æ–≤ –Ω–∞ –ø–æ–∫—É–ø–∫—É –∫–µ–π—Å–æ–≤
	keys, err = r.redis.Keys(r.ctx, "case_buy_limit:*").Result()
	if err != nil {
		log.Printf("–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–ª—é—á–µ–π case_buy_limit: %v", err)
		return
	}
	for _, key := range keys {
		r.redis.Del(r.ctx, key)
		log.Printf("–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —É–¥–∞–ª–µ–Ω –∫–ª—é—á case_buy_limit: %s", key)
	}

	// –°–±—Ä–æ—Å –ª–∏–º–∏—Ç–æ–≤ –Ω–∞ –µ–∂–µ–¥–Ω–µ–≤–Ω—ã–π –∫–µ–π—Å
	keys, err = r.redis.Keys(r.ctx, "daily_case:*").Result()
	if err != nil {
		log.Printf("–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–ª—é—á–µ–π daily_case: %v", err)
		return
	}
	for _, key := range keys {
		r.redis.Del(r.ctx, key)
		log.Printf("–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —É–¥–∞–ª–µ–Ω –∫–ª—é—á daily_case: %s", key)
	}
}

// Stop –ø—Ä–µ–∫—Ä–∞—â–∞–µ—Ç —Ä–∞–±–æ—Ç—É –≥–æ—Ä—É—Ç–∏–Ω—ã —Å–±—Ä–æ—Å–∞ –ª–∏–º–∏—Ç–æ–≤
func (r *Ranking) Stop() {
	close(r.stopResetChan)
}

// GetBitcoinPrice –ø–æ–ª—É—á–∞–µ—Ç —Ç–µ–∫—É—â–∏–π –∫—É—Ä—Å –±–∏—Ç–∫–æ–π–Ω–∞
func (r *Ranking) GetBitcoinPrice() (float64, error) {
	cacheKey := "bitcoin_price"

	// –ü—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å –∏–∑ –∫—ç—à–∞
	cached, err := r.redis.Get(r.ctx, cacheKey).Result()
	if err == nil {
		cachedPrice, _ := strconv.ParseFloat(cached, 64)
		// –ï—Å–ª–∏ –∫—ç—à —Å–≤–µ–∂–∏–π (–º–µ–Ω–µ–µ 10 –º–∏–Ω—É—Ç), –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ
		if time.Since(r.BitcoinTracker.LastUpdate) < 10*time.Minute {
			return cachedPrice, nil
		}
	}

	// –ü–æ–ª—É—á–∞–µ–º —Å–≤–µ–∂–∏–π –∫—É—Ä—Å
	resp, err := http.Get("https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd")
	if err != nil {
		log.Printf("–û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –∫ CoinGecko: %v", err)

		// Fallback: –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ—Å–ª–µ–¥–Ω–µ–µ –∏–∑–≤–µ—Å—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
		if r.BitcoinTracker.CurrentPrice > 0 {
			return r.BitcoinTracker.CurrentPrice, nil
		}
		return 0, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		log.Printf("CoinGecko API –≤–µ—Ä–Ω—É–ª —Å—Ç–∞—Ç—É—Å: %d", resp.StatusCode)
		if r.BitcoinTracker.CurrentPrice > 0 {
			return r.BitcoinTracker.CurrentPrice, nil
		}
		return 0, fmt.Errorf("API –≤–µ—Ä–Ω—É–ª —Å—Ç–∞—Ç—É—Å %d", resp.StatusCode)
	}

	var data map[string]map[string]float64
	if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
		log.Printf("–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –æ—Ç–≤–µ—Ç–∞ CoinGecko: %v", err)
		if r.BitcoinTracker.CurrentPrice > 0 {
			return r.BitcoinTracker.CurrentPrice, nil
		}
		return 0, err
	}

	price := data["bitcoin"]["usd"]

	// –û–±–Ω–æ–≤–ª—è–µ–º —Ç—Ä–µ–∫–µ—Ä
	r.BitcoinTracker.mu.Lock()
	r.BitcoinTracker.PreviousPrice = r.BitcoinTracker.CurrentPrice
	r.BitcoinTracker.CurrentPrice = price
	r.BitcoinTracker.LastUpdate = time.Now()

	// –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∏—Å—Ç–æ—Ä–∏—é (–ø–æ—Å–ª–µ–¥–Ω–∏–µ 24 —á–∞—Å–∞)
	r.BitcoinTracker.PriceHistory = append(r.BitcoinTracker.PriceHistory, price)
	if len(r.BitcoinTracker.PriceHistory) > 288 { // 288 –∑–∞–ø–∏—Å–µ–π = 24 —á–∞—Å–∞ (–∫–∞–∂–¥—ã–µ 5 –º–∏–Ω)
		r.BitcoinTracker.PriceHistory = r.BitcoinTracker.PriceHistory[1:]
	}
	r.BitcoinTracker.mu.Unlock()

	// –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ Redis –Ω–∞ 10 –º–∏–Ω—É—Ç
	r.redis.Set(r.ctx, cacheKey, fmt.Sprintf("%.2f", price), 10*time.Minute)

	return price, nil
}

// Get24hAverage –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ä–µ–¥–Ω—é—é —Ü–µ–Ω—É BTC –∑–∞ 24 —á–∞—Å–∞
func (bt *BitcoinTracker) Get24hAverage() float64 {
	bt.mu.Lock()
	defer bt.mu.Unlock()

	if len(bt.PriceHistory) == 0 {
		return bt.CurrentPrice
	}

	sum := 0.0
	for _, price := range bt.PriceHistory {
		sum += price
	}
	return sum / float64(len(bt.PriceHistory))
}

// CalculateVolatility –≤—ã—á–∏—Å–ª—è–µ—Ç –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å BTC
func (bt *BitcoinTracker) CalculateVolatility() float64 {
	bt.mu.Lock()
	defer bt.mu.Unlock()

	if len(bt.PriceHistory) < 2 {
		return 0.2 // –ë–∞–∑–æ–≤–∞—è –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å 20% –µ—Å–ª–∏ –¥–∞–Ω–Ω—ã—Ö –º–∞–ª–æ
	}

	// –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 12 –∑–Ω–∞—á–µ–Ω–∏–π (1 —á–∞—Å –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –∫–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç)
	recentPrices := bt.PriceHistory
	if len(recentPrices) > 12 {
		recentPrices = recentPrices[len(recentPrices)-12:]
	}

	// –í—ã—á–∏—Å–ª—è–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –¥–ª—è –±–æ–ª–µ–µ —Ç–æ—á–Ω–æ–π –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏
	sum := 0.0
	for _, price := range recentPrices {
		sum += price
	}
	mean := sum / float64(len(recentPrices))

	variance := 0.0
	for _, price := range recentPrices {
		variance += math.Pow(price-mean, 2)
	}
	variance /= float64(len(recentPrices))
	stdDev := math.Sqrt(variance)

	// –í–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å –∫–∞–∫ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –≤–∞—Ä–∏–∞—Ü–∏–∏
	volatility := stdDev / mean

	// –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –≤–æ—Å–ø—Ä–∏–Ω–∏–º–∞–µ–º—É—é –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å –≤ 2 —Ä–∞–∑–∞
	return math.Min(1.0, volatility*2.0)
}

// CalculateNFTPrice –≤—ã—á–∏—Å–ª—è–µ—Ç —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É NFT
func (r *Ranking) CalculateNFTPrice(nft NFT) int {
	// –ó–∞—â–∏—Ç–∞ –æ—Ç –Ω—É–ª–µ–≤–æ–π –±–∞–∑–æ–≤–æ–π —Ü–µ–Ω—ã
	if nft.BasePriceUSD == 0 {
		log.Printf("WARNING: Zero base price for NFT %s (Rarity: %s)", nft.Name, nft.Rarity)
		// –ò—Å–ø–æ–ª—å–∑—É–µ–º –±–∞–∑–æ–≤—É—é —Ü–µ–Ω—É –∏–∑ –º–∞–ø—ã –∫–∞–∫ fallback
		basePrice, exists := BaseRarityPrices[nft.Rarity]
		if !exists {
			basePrice = 10 // Fallback –∑–Ω–∞—á–µ–Ω–∏–µ
		}
		nft.BasePriceUSD = basePrice
	}

	basePrice := nft.BasePriceUSD
	rarityVolatility := RarityVolatility[nft.Rarity]

	// –î–ª—è Common - –º–µ–Ω—å—à–∞—è –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å
	if nft.Rarity == "Common" {
		// Common –≤—Å–µ –µ—â–µ –±–æ–ª–µ–µ —Å—Ç–∞–±–∏–ª—å–Ω—ã, –Ω–æ –Ω–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω—ã
		btcVolatility := r.BitcoinTracker.CalculateVolatility()
		currentBtcPrice := r.BitcoinTracker.CurrentPrice
		averageBtcPrice := r.BitcoinTracker.Get24hAverage()

		btcDeviation := (currentBtcPrice - averageBtcPrice) / averageBtcPrice
		// –ú–µ–Ω—å—à–µ–µ –≤–ª–∏—è–Ω–∏–µ –Ω–∞ Common
		impactStrength := btcVolatility * rarityVolatility * 0.3

		volatilityMultiplier := 1.0 + (btcDeviation * impactStrength)
		// –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–±—Ä–æ—Å –¥–ª—è Common
		volatilityMultiplier = math.Max(0.8, math.Min(1.2, volatilityMultiplier))

		finalPrice := basePrice * volatilityMultiplier
		return int(finalPrice)
	}

	// –î–ª—è Rare –∏ –≤—ã—à–µ - –ø–æ–ª–Ω–∞—è –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å
	btcVolatility := r.BitcoinTracker.CalculateVolatility()
	currentBtcPrice := r.BitcoinTracker.CurrentPrice
	averageBtcPrice := r.BitcoinTracker.Get24hAverage()

	// –û—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ BTC –æ—Ç —Å—Ä–µ–¥–Ω–µ–≥–æ
	btcDeviation := (currentBtcPrice - averageBtcPrice) / averageBtcPrice

	// –°–∏–ª–∞ –≤–æ–∑–¥–µ–π—Å—Ç–≤–∏—è = –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å BTC * –º–Ω–æ–∂–∏—Ç–µ–ª—å —Ä–µ–¥–∫–æ—Å—Ç–∏
	// –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –≤–ª–∏—è–Ω–∏–µ –≤ 3 —Ä–∞–∑–∞ –¥–ª—è –±–æ–ª—å—à–∏—Ö –∫–æ–ª–µ–±–∞–Ω–∏–π
	impactStrength := btcVolatility * rarityVolatility * 30.0

	// –ü—Ä–∏–º–µ–Ω—è–µ–º –≤–æ–∑–¥–µ–π—Å—Ç–≤–∏–µ
	volatilityMultiplier := 1.0 + (btcDeviation * impactStrength)

	// –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–±—Ä–æ—Å –¥–ª—è —Ä–µ–¥–∫–∏—Ö NFT
	var minMultiplier, maxMultiplier float64

	switch nft.Rarity {
	case "Rare":
		minMultiplier, maxMultiplier = 0.7, 1.5
	case "Super-rare":
		minMultiplier, maxMultiplier = 0.6, 2.0
	case "Epic":
		minMultiplier, maxMultiplier = 0.5, 30.0
	case "Nephrite":
		minMultiplier, maxMultiplier = 0.4, 40.0
	case "Exotic":
		minMultiplier, maxMultiplier = 0.3, 50.0
	case "Legendary":
		minMultiplier, maxMultiplier = 0.2, 60.0 // –õ–µ–≥–µ–Ω–¥–∞—Ä–∫–∏ –º–æ–≥—É—Ç —É–ø–∞—Å—Ç—å –¥–æ 20% –∏–ª–∏ –≤—ã—Ä–∞—Å—Ç–∏ –≤ 6 —Ä–∞–∑
	default:
		minMultiplier, maxMultiplier = 0.1, 100.0
	}

	// –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–±—Ä–æ—Å
	volatilityMultiplier = math.Max(minMultiplier, math.Min(maxMultiplier, volatilityMultiplier))

	finalPrice := basePrice * volatilityMultiplier

	log.Printf("–¶–µ–Ω–∞ %s: –±–∞–∑–∞ $%.0f, –º–Ω–æ–∂–∏—Ç–µ–ª—å %.2f, –∏—Ç–æ–≥–æ $%.0f (BTC –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ: %.1f%%)",
		nft.Rarity, basePrice, volatilityMultiplier, finalPrice, btcDeviation*100)

	return int(finalPrice)
}

// min –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∏–∑ –¥–≤—É—Ö —á–∏—Å–µ–ª
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// StartBitcoinUpdater –∑–∞–ø—É—Å–∫–∞–µ—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—É—Ä—Å–∞ BTC –∫–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç
func (r *Ranking) StartBitcoinUpdater() {
	go func() {
		ticker := time.NewTicker(5 * time.Minute)
		defer ticker.Stop()

		for {
			select {
			case <-ticker.C:
				price, err := r.GetBitcoinPrice()
				if err != nil {
					log.Printf("–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫—É—Ä—Å–∞ BTC: %v", err)
					continue
				}
				log.Printf("‚úÖ –ö—É—Ä—Å BTC –æ–±–Ω–æ–≤–ª–µ–Ω: $%.2f", price)
			case <-r.stopResetChan:
				return
			}
		}
	}()
}

// getBitcoinPriceFromAlternative –ø–æ–ª—É—á–∞–µ—Ç –∫—É—Ä—Å —Å –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–æ–≥–æ API
func (r *Ranking) getBitcoinPriceFromAlternative() (float64, error) {
	// –ü–æ–ø—Ä–æ–±—É–µ–º Binance API
	resp, err := http.Get("https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT")
	if err != nil {
		return 0, err
	}
	defer resp.Body.Close()

	var binanceData struct {
		Symbol string `json:"symbol"`
		Price  string `json:"price"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&binanceData); err != nil {
		return 0, err
	}

	price, err := strconv.ParseFloat(binanceData.Price, 64)
	if err != nil {
		return 0, err
	}

	return price, nil
}
